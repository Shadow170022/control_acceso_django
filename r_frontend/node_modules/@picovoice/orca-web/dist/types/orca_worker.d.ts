import { OrcaModel, OrcaSynthesizeParams, OrcaSynthesizeResult, OrcaStreamSynthesizeResult } from './types';
declare class StreamWorker {
    readonly _worker: Worker;
    constructor(orcaWorker: Worker);
    /**
     * Adds a chunk of text to the Stream object in a worker and generates audio if enough text has been added.
     * This function is expected to be called multiple times with consecutive chunks of text from a text stream.
     * The incoming text is buffered as it arrives until there is enough context to convert a chunk of the
     * buffered text into audio. The caller needs to use `OrcaStream.flush()` to generate the audio chunk
     * for the remaining text that has not yet been synthesized.
     *
     * @param text A chunk of text from a text input stream, comprised of valid characters.
     *             Valid characters can be retrieved by calling `validCharacters`.
     *             Custom pronunciations can be embedded in the text via the syntax `{word|pronunciation}`.
     *             They need to be added in a single call to this function.
     *             The pronunciation is expressed in ARPAbet format, e.g.: `I {liv|L IH V} in {Sevilla|S EH V IY Y AH}`.
     * @return The generated audio as a sequence of 16-bit linearly-encoded integers, `null` if no
     *         audio chunk has been produced.
     */
    synthesize(text: string): Promise<OrcaStreamSynthesizeResult>;
    /**
     * Generates audio for all the buffered text that was added to the OrcaStream object
     * via `OrcaStream.synthesize()`.
     *
     * @return The generated audio as a sequence of 16-bit linearly-encoded integers, `null` if no
     *         audio chunk has been produced.
     */
    flush(): Promise<OrcaStreamSynthesizeResult>;
    /**
     * Releases the resources acquired by the OrcaStream object.
     */
    close(): Promise<void>;
}
export type OrcaStreamWorker = StreamWorker;
export declare class OrcaWorker {
    private readonly _worker;
    private readonly _version;
    private readonly _sampleRate;
    private readonly _maxCharacterLimit;
    private readonly _validCharacters;
    private static _wasm;
    private static _wasmSimd;
    private static _sdk;
    private constructor();
    /**
     * Get Orca engine version.
     */
    get version(): string;
    /**
     * Get sample rate.
     */
    get sampleRate(): number;
    /**
     * Get maximum character limit.
     */
    get maxCharacterLimit(): number;
    /**
     * Get valid characters.
     */
    get validCharacters(): string[];
    /**
     * Get Orca worker instance.
     */
    get worker(): Worker;
    /**
     * Set base64 wasm file.
     * @param wasm Base64'd wasm file to use to initialize wasm.
     */
    static setWasm(wasm: string): void;
    /**
     * Set base64 wasm file with SIMD feature.
     * @param wasmSimd Base64'd wasm file to use to initialize wasm.
     */
    static setWasmSimd(wasmSimd: string): void;
    static setSdk(sdk: string): void;
    /**
     * Creates a worker instance of the Picovoice Orca Text-to-Speech engine.
     * Behind the scenes, it requires the WebAssembly code to load and initialize before
     * it can create an instance.
     *
     * @param accessKey AccessKey obtained from Picovoice Console (https://console.picovoice.ai/)
     * @param model Orca model options.
     * @param model.base64 The model in base64 string to initialize Orca.
     * @param model.publicPath The model path relative to the public directory.
     * @param model.customWritePath Custom path to save the model in storage.
     * Set to a different name to use multiple models across `orca` instances.
     * @param model.forceWrite Flag to overwrite the model in storage even if it exists.
     * @param model.version Version of the model file. Increment to update the model file in storage.
     *
     * @returns An instance of OrcaWorker.
     */
    static create(accessKey: string, model: OrcaModel): Promise<OrcaWorker>;
    /**
     * Generates audio from text in a worker. The returned audio contains the speech representation of the text.
     * The maximum number of characters per call to `.synthesize()` is `.maxCharacterLimit`.
     * Allowed characters are lower-case and upper-case letters and punctuation marks that can be retrieved with `.validCharacters`.
     * Custom pronunciations can be embedded in the text via the syntax `{word|pronunciation}`.
     * The pronunciation is expressed in ARPAbet format, e.g.: "I {live|L IH V} in {Sevilla|S EH V IY Y AH}".
     *
     * @param text A string of text with properties described above.
     * @param synthesizeParams Optional configuration arguments.
     * @param synthesizeParams.speechRate Configure the rate of speech of the synthesized speech.
     * @param synthesizeParams.randomState Configure the random seed for the synthesized speech.
     *
     * @return A result object containing the generated audio as a sequence of 16-bit linearly-encoded integers
     *         and a sequence of OrcaAlignment objects representing the word alignments.
     */
    synthesize(text: string, synthesizeParams?: OrcaSynthesizeParams): Promise<OrcaSynthesizeResult>;
    /**
     * Releases resources acquired by WebAssembly module.
     */
    release(): Promise<void>;
    /**
     * Opens a new OrcaStream object in a worker.
     *
     * @param synthesizeParams Optional configuration arguments.
     * @param synthesizeParams.speechRate Configure the rate of speech of the synthesized speech.
     * @param synthesizeParams.randomState Configure the random seed for the synthesized speech.
     */
    streamOpen(synthesizeParams?: OrcaSynthesizeParams): Promise<OrcaStreamWorker>;
    /**
     * Terminates the active worker. Stops all requests being handled by worker.
     */
    terminate(): void;
}
export {};
//# sourceMappingURL=orca_worker.d.ts.map